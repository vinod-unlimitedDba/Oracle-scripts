
PROMPT PROMPT PROMPT SUMMARY OF PROCESS COUNT AND SESSION COUNT PROMPT __________________________________________ PROMPT select a.ProcessCount,b.SessionCount from (select count(1) ProcessCount from v$process) a, (select count(1) SessionCount from v$session) b / PROMPT PROMPT SESSION DETAILS PROMPT _______________ break on report compute SUM of tot on report compute SUM of active on report compute SUM of inactive on report col USERNAME for a15 select DECODE(username,NULL,'INTERNAL',USERNAME) Username, count(*) TOT, COUNT(DECODE(status,'ACTIVE',STATUS)) ACTIVE, COUNT(DECODE(status,'INACTIVE',STATUS)) INACTIVE from gv$session where status in ('ACTIVE','INACTIVE') group by username;

prompt A-Script: Display CURRENT active sessionsâ€¦
select count() ,sql_id , case state when 'WAITING' then 'WAITING' else 'ON CPU' end state , case state when 'WAITING' then event else 'On CPU / runqueue' end event from gv$session where status='ACTIVE' and type !='BACKGROUND' and wait_class != 'Idle' and sid != (select sid from gv$mystat where rownum=1) group by sql_id , case state when 'WAITING' then 'WAITING' else 'ON CPU' end , case state when 'WAITING' then event else 'On CPU / runqueue' end order by count() desc /

PROMPT PROMPT PROMPT NUMBER OF CONNECTED SESSIONS PROMPT ============================= select substr(a.spid,1,9) pid, substr(b.sid,1,5) sid, status, TO_CHAR(logon_time,'DD-Mon-YYYY HH24:MI:SS'), substr(b.serial#,1,5) ser#, substr(b.machine,1,6) box, substr(b.username,1,10) username, substr(b.osuser,1,8) os_user, substr(b.program,1,30) program from v$session b, v$process a where b.paddr = a.addr and type='USER' order by status;

set pages 50000 lines 32767 col USERNAME for a10 col MACHINE for a15 col PROGRAM for a40

SELECT USERNAME,machine,inst_id,sid,serial#,PROGRAM, to_char(logon_time,'dd-mm-yy hh:mi:ss AM')"Logon Time", ROUND((SYSDATE-LOGON_TIME)(2460),1) as MINUTES_LOGGED_ON, ROUND(LAST_CALL_ET/60,1) as Minutes_FOR_CURRENT_SQL From gv$session WHERE STATUS='ACTIVE' AND USERNAME IS NOT NULL and ROUND((SYSDATE-LOGON_TIME)(2460),1) > 60 ORDER BY MINUTES_LOGGED_ON DESC;

SELECT LPAD(' ', 2*(LEVEL-1)) || sid || ' (' || username || ')' AS blocking_chain FROM ( SELECT sid, username, blocking_session FROM v$session -- Include sessions that are waiting (have a blocking_session) -- or sessions that are themselves blocking others. WHERE blocking_session IS NOT NULL OR sid IN (SELECT DISTINCT blocking_session FROM v$session WHERE blocking_session IS NOT NULL) ) START WITH blocking_session IS NULL CONNECT BY PRIOR sid = blocking_session;

set feedback off set serveroutput on size 9999 column username format a20 column sql_text format a55 word_wrapped begin for x in (select username||'('||sid||','||serial#||') ospid = '|| process || ' program = ' || program username, to_char(LOGON_TIME,' Day HH24:MI') logon_time, to_char(sysdate,' Day HH24:MI') current_time, sql_address, sql_hash_value from v$session where status = 'ACTIVE' and rawtohex(sql_address) <> '00' and username is not null ) loop for y in (select sql_text from v$sqlarea where address = x.sql_address ) loop if ( y.sql_text not like '%listener.get_cmd%' and y.sql_text not like '%RAWTOHEX(SQL_ADDRESS)%' ) then dbms_output.put_line( '--------------------' ); dbms_output.put_line( x.username ); dbms_output.put_line( x.logon_time || ' ' || x.current_time || ' SQL#=' || x.sql_hash_value); dbms_output.put_line( substr( y.sql_text, 1, 250 ) ); end if; end loop; end loop; end; /

